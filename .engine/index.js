// Generated by LiveScript 1.3.1
(function(){
  var express, colors, path, pino, lderror, pinoHttp, redis, util, bodyParser, csurf, auth, route, watch, redisNode, pug, postgresql, secret, defaultConfig, backend;
  express = require('express');
  colors = require('colors');
  path = require('path');
  pino = require('pino');
  lderror = require('lderror');
  pinoHttp = require('pino-http');
  redis = require('redis');
  util = require('util');
  bodyParser = require('body-parser');
  csurf = require('csurf');
  auth = require('./auth');
  route = require('./route');
  watch = require('./watch');
  redisNode = require('./redis-node');
  pug = require('./module/view/pug');
  postgresql = require('./module/db/postgresql');
  secret = require('../secret');
  defaultConfig = {
    limit: '10mb',
    port: 3000
  };
  backend = function(opt){
    opt == null && (opt = {});
    this.opt = opt;
    import$(this, {
      mode: process.env.NODE_ENV,
      production: process.env.NODE_ENVT === 'production',
      middleware: {},
      config: import$(import$({}, defaultConfig), opt.config),
      server: null,
      app: null,
      log: null,
      route: {},
      store: {}
    });
    return this;
  };
  import$(backend, {
    create: function(opt){
      var b;
      opt == null && (opt = {});
      b = new backend(opt);
      return b.start().then(function(){
        return b;
      });
    },
    middleware: {
      errorHandler: function(err, req, res, next){
        var e;
        try {
          if (!err) {
            return next();
          }
          if (err.code === 'EBADCSRFTOKEN') {
            err = new lderror(1005);
          }
          if (lderror.id(err)) {
            delete err.stack;
            if (!/^\/api/.exec(req.url)) {
              res.set({
                "Content-Type": "text/html",
                "X-Accel-Redirect": "/err/490"
              });
            }
            res.cookie("lderror", JSON.stringify(err), {
              maxAge: 60000,
              httpOnly: false,
              secure: true,
              sameSite: 'Strict'
            });
            return res.status(490).send(err);
          } else if (err instanceof URIError && (err.stack + "").startsWith('URIError: Failed to decode param')) {
            return res.status(400).send();
          }
        } catch (e$) {
          e = e$;
          req.log.error({
            err: e
          }, "exception occurred while handling other exceptions".red);
          req.log.error("original exception follows:".red);
        }
        req.log.error({
          err: err
        }, ("unhandled exception occurred " + (err.message ? ': ' + err.message : '')).red);
        return res.status(500).send();
      }
    }
  });
  backend.prototype = import$(Object.create(Object.prototype), {
    listen: function(){
      var this$ = this;
      return new Promise(function(res, rej){
        if (!this$.server) {
          return this$.server = this$.app.listen(this$.config.port, function(){
            return res(this$.server);
          });
        } else {
          return server.listen(this$.config.port, function(){
            return res(this.server);
          });
        }
      });
    },
    watch: function(){
      if (this.config.build && this.config.build.enabled) {
        return watch(this).init(this.config.build);
      }
    },
    start: function(){
      var this$ = this;
      return Promise.resolve().then(function(){
        var log, app, api;
        this$.log = log = pino({
          level: this$.production ? 'info' : 'debug'
        });
        this$.logServer = log.child({
          module: 'server'
        });
        process.on('uncaughtException', function(err, origin){
          this.logServer.error({
            err: err
          }, "uncaught exception ocurred, outside express routes".red);
          this.logServer.error("terminate process to reset server status".red);
          return process.exit(-1);
        });
        process.on('unhandledRejection', function(err){
          this.logServer.error({
            err: err
          }, "unhandled rejection ocurred".red);
          this.logServer.error("terminate process to reset server status".red);
          return process.exit(-1);
        });
        this$.db = new postgresql(this$);
        this$.app = this$.route.app = app = express();
        this$.store = new redisNode();
        this$.logServer.info(("initializing backend in " + app.get('env') + " mode").cyan);
        app.disable('x-powered-by');
        app.set('trust proxy', '127.0.0.1');
        app.use(pinoHttp({
          useLevel: this$.production ? 'info' : 'debug',
          logger: log.child({
            module: 'route'
          }),
          autoLogging: !this$.production
        }));
        app.use(bodyParser.json({
          limit: this$.config.limit,
          verify: function(req, res, buf, encoding){
            if (req.headers["x-hub-signature"]) {
              return req.rawBody = buf.toString();
            }
          }
        }));
        app.use(bodyParser.urlencoded({
          extended: true,
          limit: this$.config.limit
        }));
        if (app.get('env') !== 'development') {
          app.enable('view cache');
        }
        app.engine('pug', pug(this$));
        app.set('view engine', 'pug');
        app.set('views', path.join(__dirname, '../src/pug/'));
        app.locals.viewdir = path.join(__dirname, '../.view/');
        app.locals.basedir = app.get('views');
        this$.route.api = api = express.Router({
          mergeParams: true
        });
        this$.route.auth = express.Router({
          mergeParams: true
        });
        auth(this$);
        app.use('/api', this$.route.api);
        app.use('/api/auth', this$.route.auth);
        route(this$);
        app.use('/', express['static'](path.join(__dirname, '.')));
        app.use(function(req, res, next){
          return next(new lderror(404));
        });
        app.use(backend.middleware.errorHandler);
        return this$.listen();
      }).then(function(){
        this$.logServer.info(("listening on port " + this$.server.address().port).cyan);
        return this$.watch();
      })['catch'](function(err){
        this$.logServer.error({
          err: err
        }, "failed to start server. ".red);
        return process.exit(-1);
      });
    }
  });
  backend.create({
    config: secret
  });
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
