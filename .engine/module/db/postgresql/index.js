// Generated by LiveScript 1.3.1
(function(){
  var pg, crypto, bcrypt, colors, lderror, re2, curegex, reEmail, isEmail, ret;
  pg = require('pg');
  crypto = require('crypto');
  bcrypt = require('bcrypt');
  colors = require('colors');
  lderror = require('lderror');
  re2 = require('re2');
  curegex = require('curegex');
  reEmail = curegex.tw.get('email', re2);
  isEmail = function(it){
    return reEmail.exec(it);
  };
  pg.defaults.poolSize = 30;
  ret = function(backend){
    var config, log, ref$, user, password, host, database, auth, this$ = this;
    this.config = config = backend.config;
    this.log = log = backend.log.child({
      module: 'DB'
    });
    ref$ = config.db.postgresql, user = ref$.user, password = ref$.password, host = ref$.host, database = ref$.database;
    this.uri = "postgres://" + user + ":" + password + "@" + host + "/" + database;
    this.pool = new pg.Pool({
      connectionString: this.uri,
      max: config.db.postgresql.poolSize || 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000
    });
    this.pool.on('error', function(err, client){
      return log.error("db pool error".red);
    });
    this.auth = auth = {
      user: {
        serialize: function(u){
          u == null && (u = {});
          return Promise.resolve(u);
        },
        deserialize: function(v){
          v == null && (v = {});
          return Promise.resolve(v);
        },
        hashing: function(password, doMD5, doBcrypt){
          doMD5 == null && (doMD5 = true);
          doBcrypt == null && (doBcrypt = true);
          return new Promise(function(res, rej){
            var ret;
            ret = doMD5 ? crypto.createHash('md5').update(password).digest('hex') : password;
            if (doBcrypt) {
              return bcrypt.genSalt(12, function(e, salt){
                return bcrypt.hash(ret, salt, function(e, hash){
                  return res(hash);
                });
              });
            } else {
              return res(ret);
            }
          });
        },
        compare: function(password, hash){
          password == null && (password = '');
          return new Promise(function(res, rej){
            var md5;
            md5 = crypto.createHash('md5').update(password).digest('hex');
            return bcrypt.compare(md5, hash, function(e, ret){
              if (ret) {
                return res();
              } else {
                return rej(new lderror(1012));
              }
            });
          });
        },
        get: function(arg$){
          var username, password, method, detail, create;
          username = arg$.username, password = arg$.password, method = arg$.method, detail = arg$.detail, create = arg$.create;
          username = username.toLowerCase();
          if (!isEmail(username)) {
            return Promise.reject(new lderror(1015));
          }
          return this$.query("select * from users where username = $1", [username]).then(function(ret){
            var user;
            ret == null && (ret = {});
            if (!(user = (ret.rows || (ret.rows = []))[0]) && !create) {
              return Promise.reject(new lderror(1012));
            }
            if (!user) {
              return this$.auth.user.create({
                username: username,
                password: password,
                method: method,
                detail: detail
              });
            }
            if (!(method === 'local' || user.method === 'local')) {
              delete user.password;
              return user;
            }
            return this$.auth.user.compare(password, user.password).then(function(){
              return user;
            });
          }).then(function(user){
            var ref$;
            if (((ref$ = user.config || (user.config = {})).consent || (ref$.consent = {})).cookie) {
              return user;
            }
            user.config.consent.cookie = new Date().getTime();
            return this$.query("update users set config = $2 where key = $1", [user.key, user.config]).then(function(){
              return user;
            });
          }).then(function(user){
            delete user.password;
            return user;
          });
        },
        create: function(arg$){
          var username, password, method, detail, config;
          username = arg$.username, password = arg$.password, method = arg$.method, detail = arg$.detail, config = arg$.config;
          username = username.toLowerCase();
          if (!isEmail(username)) {
            return Promise.reject(new lderror(1015));
          }
          return Promise.resolve().then(function(){
            if (method === 'local') {
              return this$.auth.user.hashing(password);
            } else {
              return password;
            }
          }).then(function(password){
            var displayname, user;
            displayname = detail ? detail.displayname || detail.username : void 8;
            if (!displayname) {
              displayname = username.replace(/@.+$/, "");
            }
            (config.consent || (config.consent = {})).cookie = new Date().getTime();
            user = {
              username: username,
              password: password,
              method: method,
              displayname: displayname,
              detail: detail,
              config: config,
              createdtime: new Date()
            };
            return this$.query("insert into users (username,password,method,displayname,createdtime,detail,config)\nvalues ($1,$2,$3,$4,$5,$6,$7)\nreturning key", [username, password, method, displayname, new Date().toUTCString(), detail, config]).then(function(r){
              r == null && (r = {});
              if (!(r = (r.rows || (r.rows = []))[0])) {
                return Promise.reject(500);
              }
              return user.key = r.key, user;
            });
          });
        }
      },
      session: {
        get: function(sid, cb){
          this$.query("select * from sessions where key=$1", [sid]).then(function(it){
            return cb(null, ((it.rows || (it.rows = []))[0] || {}).detail);
          })['catch'](function(err){
            return [
              log.error({
                err: err
              }, "get session failed"), cb(err)
            ];
          });
        },
        set: function(sid, session, cb){
          this$.query(["insert into sessions (key,detail) values", "($1, $2) on conflict (key) do update set detail=$2"].join(" "), [sid, session]).then(function(){
            return cb();
          })['catch'](function(err){
            return [
              log.error({
                err: err
              }, "set session failed"), cb()
            ];
          });
        },
        destroy: function(sid, cb){
          this$.query("delete from sessions where key = $1", [sid]).then(function(){
            return cb();
          })['catch'](function(err){
            return [
              log.error({
                err: err
              }, "destroy session failed"), cb()
            ];
          });
        }
      }
    };
    return this;
  };
  ret.prototype = {
    query: function(q, p){
      return this.pool.connect().then(function(client){
        return client.query(q, p).then(function(ret){
          client.release();
          return ret;
        });
      })['catch'](function(it){
        return Promise.reject(new lderror({
          err: it,
          id: 0,
          query: q,
          message: "database query error"
        }));
      });
    }
  };
  module.exports = ret;
}).call(this);
