// Generated by LiveScript 1.3.1
(function(){
  var pg, crypto, bcrypt, colors, lderror, ret;
  pg = require('pg');
  crypto = require('crypto');
  bcrypt = require('bcrypt');
  colors = require('colors');
  lderror = require('lderror');
  pg.defaults.poolSize = 30;
  ret = function(backend){
    var config, log, ref$, user, password, host, database, authio, this$ = this;
    this.config = config = backend.config;
    this.log = log = backend.log.child({
      module: 'DB'
    });
    ref$ = config.db.postgresql, user = ref$.user, password = ref$.password, host = ref$.host, database = ref$.database;
    this.uri = "postgres://" + user + ":" + password + "@" + host + "/" + database;
    this.pool = new pg.Pool({
      connectionString: this.uri,
      max: config.db.postgresql.poolSize || 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000
    });
    this.pool.on('error', function(err, client){
      return log.error("db pool error".red);
    });
    this.authio = authio = {
      user: {
        serialize: function(user){
          user == null && (user = {});
          return Promise.resolve(user || {});
        },
        deserialize: function(v){
          return Promise.resolve(v || {});
        },
        hashing: function(password, doMD5, doBcrypt){
          doMD5 == null && (doMD5 = true);
          doBcrypt == null && (doBcrypt = true);
          return new Promise(function(res, rej){
            var ret;
            ret = doMD5 ? crypto.createHash('md5').update(password).digest('hex') : password;
            if (doBcrypt) {
              return bcrypt.genSalt(12, function(e, salt){
                return bcrypt.hash(ret, salt, function(e, hash){
                  return res(hash);
                });
              });
            } else {
              return res(ret);
            }
          });
        },
        compare: function(password, hash){
          password == null && (password = '');
          return new Promise(function(res, rej){
            var md5;
            md5 = crypto.createHash('md5').update(password).digest('hex');
            return bcrypt.compare(md5, hash, function(e, ret){
              if (ret) {
                return res();
              } else {
                return rej(new Error());
              }
            });
          });
        },
        get: function(username, password, usepasswd, detail, doCreate){
          var usernameLower, user;
          doCreate == null && (doCreate = false);
          usernameLower = username.toLowerCase();
          if (!/^[-a-z0-9~!$%^&*_=+}{\'?]+(\.[-a-z0-9~!$%^&*_=+}{\'?]+)*@([a-z0-9_][-a-z0-9_]*(\.[-a-z0-9_]+)*\.[a-z]{2,}|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,5})?$/i.exec(username)) {
            return Promise.reject(lderror(1015));
          }
          user = {};
          return this$.query("select * from users where username = $1 or username = $2", [username, usernameLower]).then(function(users){
            users == null && (users = {});
            user = users.rows.filter(function(it){
              return it.username === username;
            })[0];
            if (!user) {
              user = users.rows.filter(function(it){
                return it.username === usernameLower;
              })[0];
            }
            if (!user && !doCreate) {
              return Promise.reject(new lderror(1012));
            }
            if (!user && doCreate) {
              return this$.authio.user.create(usernameLower, password, usepasswd, detail);
            } else if (user && !(usepasswd || user.usepasswd)) {
              delete user.password;
              return user;
            }
            return this$.authio.user.compare(password, user.password);
          }).then(function(it){
            var ref$;
            if (it) {
              user = import$(user
                ? user
                : {}, it);
            }
            if (!((ref$ = user.config || (user.config = {})).consent || (ref$.consent = {})).cookie) {
              ((ref$ = user.config || (user.config = {})).consent || (ref$.consent = {})).cookie = new Date().getTime();
              return this$.query("update users set config = $2 where key = $1", [user.key, user.config]);
            }
          }).then(function(){
            delete user.password;
            return user;
          });
        },
        create: function(username, password, usepasswd, detail, config){
          var user;
          detail == null && (detail = {});
          config == null && (config = {});
          user = {};
          username = username.toLowerCase();
          if (!/^[-a-z0-9~!$%^&*_=+}{\'?]+(\.[-a-z0-9~!$%^&*_=+}{\'?]+)*@([a-z0-9_][-a-z0-9_]*(\.[-a-z0-9_]+)*\.[a-z]{2,}|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,5})?$/i.exec(username)) {
            return Promise.reject(new lderror(1015));
          }
          return this$.authio.user.hashing(password, usepasswd, usepasswd).then(function(pwHashed){
            var displayname;
            displayname = detail ? detail.displayname || detail.username : void 8;
            if (!displayname) {
              displayname = username.replace(/@.+$/, "");
            }
            (config.consent || (config.consent = {})).cookie = new Date().getTime();
            user.username = username;
            user.password = pwHashed;
            user.usepasswd = usepasswd;
            user.displayname = displayname;
            user.detail = detail;
            user.config = config;
            user.createdtime = new Date();
            return this$.query(["insert into users", "(username,password,usepasswd,displayname,createdtime,detail,config) values", "($1,$2,$3,$4,$5,$6,$7) returning key"].join(" "), [user.username, user.password, user.usepasswd, user.displayname, new Date().toUTCString(), user.detail, user.config]);
          }).then(function(r){
            var key;
            key = (r.rows || (r.rows = []))[0].key;
            return user.key = key, user;
          });
        }
      },
      session: {
        get: function(sid, cb){
          this$.query("select * from sessions where key=$1", [sid]).then(function(it){
            return cb(null, ((it.rows || (it.rows = []))[0] || {}).detail);
          })['catch'](function(err){
            return [
              log.error({
                err: err
              }, "get session failed"), cb(err)
            ];
          });
        },
        set: function(sid, session, cb){
          this$.query(["insert into sessions (key,detail) values", "($1, $2) on conflict (key) do update set detail=$2"].join(" "), [sid, session]).then(function(){
            return cb();
          })['catch'](function(err){
            return [
              log.error({
                err: err
              }, "set session failed"), cb()
            ];
          });
        },
        destroy: function(sid, cb){
          this$.query("delete from sessions where key = $1", [sid]).then(function(){
            return cb();
          })['catch'](function(err){
            return [
              log.error({
                err: err
              }, "destroy session failed"), cb()
            ];
          });
        }
      }
    };
    return this;
  };
  ret.prototype = {
    query: function(q, p){
      return this.pool.connect().then(function(client){
        return client.query(q, p).then(function(ret){
          client.release();
          return ret;
        });
      })['catch'](function(it){
        return Promise.reject(new lderror({
          err: it,
          id: 0,
          query: q,
          message: "database query error"
        }));
      });
    }
  };
  /*
  ret.prototype = do
    query: (q, p) ->
      try
        (client) <- @pool.connect!then _
        (ret) <- client.query q, p .then _
        client.release!
        return ret
      catch e
        console.log e
        return Promise.reject(e)
  */
  module.exports = ret;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
