// Generated by LiveScript 1.3.1
(function(){
  var fs, path, pug, pugExtapi, reload, engine;
  fs = require('fs');
  path = require('path');
  pug = require('pug');
  pugExtapi = require("../../watch/build/pug").extapi;
  reload = require("require-reload")(require);
  engine = function(backend){
    var pugCached, _log, log;
    pugCached = {};
    _log = backend.log.child({
      module: 'view'
    });
    log = function(f, opt, t, type, cache){
      f = f.replace(opt.basedir, '');
      return _log.debug(f + " served in " + t + "ms (" + type + (cache ? ' cached' : '') + ")");
    };
    return function(f, opt, cb){
      var lc, intl, viewdir, basedir, pc, t1, mtime, cache, ret, t2, e, p;
      lc = {};
      if (opt.settings.env === 'development') {
        lc.dev = true;
      }
      lc.cache = true || opt.settings['view cache'];
      intl = opt.i18n ? path.join("intl", opt._locals.language) : '';
      viewdir = opt.viewdir, basedir = opt.basedir;
      pc = path.join(viewdir, intl, f.replace(basedir, '').replace(/\.pug$/, '.js'));
      try {
        t1 = Date.now();
        mtime = fs.statSync(pc).mtime;
        cache = false;
        ret = pugCached[pc] = !lc.cache || !pugCached[pc] || mtime - pugCached[pc].mtime > 0
          ? {
            js: reload(pc),
            mtime: mtime
          }
          : (cache = true, pugCached[pc]);
        if (!ret.js) {
          throw new Error();
        }
        ret = ret.js(opt);
        t2 = Date.now();
        if (lc.dev) {
          log(f, opt, t2 - t1, 'precompiled', cache);
        }
        return cb(null, ret);
      } catch (e$) {
        e = e$;
        t1 = Date.now();
        mtime = fs.statSync(f).mtime;
        p = !lc.cache || !pugCached[f] || (pugCached[f] && mtime - pugCached[f].mtime > 0)
          ? new Promise(function(res, rej){
            return fs.readFile(f, function(e, b){
              if (e) {
                return rej(e);
              } else {
                return res(b);
              }
            });
          }).then(function(buf){
            return pugCached[f] = {
              buf: buf
            };
          })
          : Promise.resolve(pugCached[f]);
        return p.then(function(obj){
          var cache, ret, ref$, t2;
          if (!(cache = obj.mtime != null && lc.cache)) {
            obj.mtime = mtime;
          }
          ret = pug.render(obj.buf, import$((ref$ = import$({}, opt), ref$.filename = f, ref$.cache = cache, ref$.basedir = basedir, ref$), pugExtapi));
          t2 = Date.now();
          if (lc.dev) {
            log(f, opt, t2 - t1, 'from pug', cache);
          }
          return cb(null, ret);
        })['catch'](function(){
          _log.error(f.replace(opt.basedir, '') + " serve failed.");
          return cb(e, null);
        });
      }
    };
  };
  engine.opt = function(opt){
    opt == null && (opt = {});
    if (opt.i18n) {
      pugExtapi.i18n = function(it){
        return opt.i18n.t(it);
      };
      return (pugExtapi.filters || (pugExtapi.filters = {})).i18n = function(t, o){
        return opt.i18n.t(t);
      };
    }
  };
  module.exports = engine;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
